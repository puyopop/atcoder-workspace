#!/usr/bin/env python3
import sys
from functools import lru_cache

@lru_cache(maxsize=None)
def g(N, K):
    if N == K == 0:
        return tuple()
    if K < 0 or N <= 0:
        return None
    # ノードの周りにi個のノードを生やす
    t = 0
    for i in range(1, N+1):
        # ノードをi個足すとcomb(i,2)個の最短距離2の頂点対ができる
        t += i
        # 足したノードの内の1つから更にノードを生やす
        res = g(N-i, K-t)
        if res is not None:
            return res + (i,)
    return None

def f(N, K):
    '''
    >>> f(5, 3)
    (1, 1, 1, 0)
    >>> f(5, 8) # return None
    >>> f(3, 1)
    (1, 0)
    >>> f(4, 2)
    (1, 1, 0)
    >>> f(4, 3)
    (2, 0)
    >>> f(5, 4)
    (2, 1, 0)
    >>> f(5, 6)
    (3, 0)
    '''
    # 始め、ノードは1つあった
    n = N - 1
    t = 0
    for i in range(1, N):
        # ノードをi個生やすとcomb(i-1,2)個の最短距離2の頂点対ができる
        t += i - 1
        # 足したノードの内の1つから更にノードを生やす
        res = g(n-i, K-t)
        if res is not None:
            return res + (i-1,)
    return res

def solve(N: int, K: int):
    from itertools import count
    edges = []
    res = f(N, K)
    if res is None:
        print(-1)
        return
    edges = []
    for i in range(len(res)):
        edges.append((i+1, i+2))
    c = count(len(res)+1)
    for p, n in enumerate(res, 1):
        for _ in range(n-1):
            edges((p, next(c)))
    print(len(edges))
    for u, v in edges:
        print(u, v)




# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    solve(N, K)

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    test()
    main()
