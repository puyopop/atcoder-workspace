#!/usr/bin/env python3
from collections import namedtuple, deque, defaultdict
Edge = namedtuple('Edge', 'to cost')
# State = namedtuple('State', 'cost node')
# Node = namedtuple('Node', 'x y d k')
D = tuple(zip((1, 0, -1, 0), (0, 1, 0, -1)))

def solve(H, W, K, sx, sy, ex, ey, C):
    # print(*C,sep="\n")
    q = deque([(0, (sx, sy, -1, 0))])
    # min_costs = defaultdict(lambda: float("inf"))
    visited = set()
    while q:
        s = q.popleft()
        #print(s)
        node = s[1]
        if (node[0], node[1], node[2]) in visited:
            continue
        if node[0] == ex and node[1] == ey:
            return s[0]
        visited.add((node[0], node[1], node[2]))
        for d, (dx, dy) in enumerate(D):
            next_node = (node[0]+dx, node[1]+dy, d, 1 if d != node[2] else node[3] % K + 1)
            if C[next_node[0]][next_node[1]] == "@":
                continue
            if (next_node[0], next_node[1], next_node[2]) in visited:
                continue
            if d == node[2]:
                if next_node[3] != 1:
                    q.appendleft((s[0], next_node))
                else:
                    q.append((s[0]+1, next_node))
            else:
                q.append((s[0]+1, next_node))
    return -1

# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    H, W, K = map(int, input().split())
    sx, sy, ex, ey = map(int, input().split())
    C = ["@" * (W+2)]
    C.extend(["@" + input() + "@" for _ in range(H)])
    C.append("@" * (W+2))
    print(solve(H, W, K, sx, sy, ex, ey, C))

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
