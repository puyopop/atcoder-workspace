#!/usr/bin/env python3
import sys

YES = "Yes"  # type: str
NO = "No"  # type: str


class Impossible(Exception):
    pass

def f(q, qq, state):
    '''
    >>> f((0, 1), None, [2, 1, 0])
    1
    >>> f((0, 1), None, [1, 2, 0])
    0
    >>> f((0, 1), None, [0, 1, 0])
    0
    >>> f((1, 2), None, [0, 1, 0])
    2
    >>> f((0, 2), None, [1, 0, 0])
    2
    >>> f((0, 1), (0, 3), [1, 1, 0])
    0
    >>> f((0, 1), (0, 3), [1, 2, 0])
    0
    >>> f((0, 1), [], [1, 1, 0])
    1
    >>> f((0, 1), None, [0, 0, 0])
    -1
    >>> f((1, 2), None, [0, 0, 0])
    -1
    >>> f((0, 1), (0, 3), [1, 0, 0])
    1
    '''
    n, m = q
    if state[n] == state[m] == 0:
        return -1
    if state[n] == state[m] == 1:
        if n in qq:
            return n
        return m
    if state[n] > state[m]:
        return m
    return n
        

def solve(N: int, A: int, B: int, C: int, s: "List[str]"):
    D = {'AB': (0, 1), 'AC': (0, 2), 'BC': (1, 2)}
    E = 'ABC'
    Q = tuple(map(lambda x: D[x], s))
    state = [A, B, C]
    for q, qq in zip(Q, Q[1:] + (tuple(),)):
        r = f(q, qq, state)
        if r == -1:
            raise Impossible
        yield E[r]
        state[r] += 1
        state[q[q.index(r)^1]] -= 1


# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    A = int(next(tokens))  # type: int
    B = int(next(tokens))  # type: int
    C = int(next(tokens))  # type: int
    s = [next(tokens) for _ in range(N)]  # type: "List[str]"
    try:
        ans = list(solve(N, A, B, C, s))
        print(YES)
        print(*ans, sep='\n')
    except Impossible:
        print(NO)

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    test()
    main()
