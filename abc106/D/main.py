#!/usr/bin/env python3
import sys


def solve_iter(N: int, M: int, Q: int, L: "List[int]", R: "List[int]", p: "List[int]", q: "List[int]"):
    f = [[0] * N for _ in range(N)]
    for l, r in zip(L, R):
        f[l-1][r-1] += 1
    dp = [[0] * (N + 1) for _ in range(N+1)]
    for h in range(N):
        for w in range(N):
            dp[h+1][w+1] = dp[h+1][w] + dp[h][w+1] - dp[h][w] + f[h][w]

    #print(*f, sep='\n')
    #print(*dp, sep='\n')
    for pp, qq in zip(p, q):
        #yield pp, qq, dp[qq][qq] - dp[qq][pp-1] - dp[pp-1][qq] + dp[pp-1][pp-1]
        yield dp[qq][qq] - dp[qq][pp-1] - dp[pp-1][qq] + dp[pp-1][pp-1]

def solve(N: int, M: int, Q: int, L: "List[int]", R: "List[int]", p: "List[int]", q: "List[int]"):
    return list(solve_iter(N, M, Q, L, R, p, q))

# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    Q = int(next(tokens))  # type: int
    L = [int()] * (M)  # type: "List[int]"
    R = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        L[i] = int(next(tokens))
        R[i] = int(next(tokens))
    p = [int()] * (Q)  # type: "List[int]"
    q = [int()] * (Q)  # type: "List[int]"
    for i in range(Q):
        p[i] = int(next(tokens))
        q[i] = int(next(tokens))
    print(*solve(N, M, Q, L, R, p, q), sep='\n')

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
