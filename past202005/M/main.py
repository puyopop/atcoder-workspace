#!/usr/bin/env python3
import sys
from collections import namedtuple
Edge = namedtuple('Edge', 'to cost')
State = namedtuple('State', 'cost node')

def dijkstra(start, edges):
    from heapq import heappush, heappop
    hq = [start]
    min_costs = {}
    while hq:
        s = heappop(hq)
        if s.node in min_costs:
            continue
        min_costs[s.node] = s.cost
        for n, c in edges[s.node]:
            if n in min_costs:
                continue
            heappush(hq, State(s.cost+c, n))
    return min_costs

def solve(N: int, M: int, u: "List[int]", v: "List[int]", s: int, K: int, t: "List[int]"):
    from collections import defaultdict
    edges = defaultdict(list)
    for uu, vv in zip(u, v):
        edges[uu].append(Edge(vv, 1))
        edges[vv].append(Edge(uu, 1))
    for uu in range(N+1):
        edges[uu].append(Edge(uu, 0))
    mcs = {}
    mcs[s] = dijkstra(State(0, s), edges)
    for tt in t:
        mcs[tt] = dijkstra(State(0, tt), edges)
    dp = [[float('inf') for _ in range(1<<len(t))] for _ in range(len(t))]
    for i in range(len(t)):
        dp[i][1<<i] = mcs[s][t[i]]
    for b in range(1<<len(t)):
        for i in range(len(t)):
            if b & (1 << i) == 0:
                continue
            for j in range(len(t)):
                if i == j:
                    continue
                if b & (1 << j) == 1:
                    continue
                dp[j][b|(1<<j)] = min(dp[j][b|(1<<j)], dp[i][b] + mcs[t[i]][t[j]])
    return min(dp[i][(1<<len(t))-1] for i in range(len(t)))

# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    u = [int()] * (M)  # type: "List[int]"
    v = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        u[i] = int(next(tokens))
        v[i] = int(next(tokens))
    s = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    t = [int(next(tokens)) for _ in range(K)]  # type: "List[int]"
    print(solve(N, M, u, v, s, K, t))

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
