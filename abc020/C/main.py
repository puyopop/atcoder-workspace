#!/usr/bin/env python3
import sys
import heapq
from itertools import product

def solve(H, W, T, s):
    (sx, sy), (gx, gy) = [(x, y) for x, y in product(range(H), range(W)) if s[x][y] in 'SG']

    def dijkstra(cost):
        hq = [(0, sx, sy)]
        visited = set()
        while hq:
            c, x, y = heapq.heappop(hq)
            if (x, y) == (gx, gy):
                return c
            if (x, y) in visited:
                continue
            visited.add((x, y))
            for dx, dy in zip((0, 0, 1, -1), (1, -1, 0, 0)):
                nx, ny = x + dx, y + dy
                if not(0 <= nx < H and 0 <= ny < W):
                    continue
                if (nx, ny) in visited:
                    continue
                cc = cost if s[nx][ny] == '#' else 1
                heapq.heappush(hq, (c+cc, nx, ny))
    
    left, right = 1, T+1
    while left+1<right:
        mid = (left + right) // 2
        if dijkstra(mid) <= T:
            left = mid
        else:
            right = mid
    return left
    

# Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    H = int(next(tokens))
    W = int(next(tokens))
    T = int(next(tokens))
    s = tuple(next(tokens) for _ in range(H))
    print(solve(H, W, T, s))
    

if __name__ == '__main__':
    main()
