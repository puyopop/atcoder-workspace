#!/usr/bin/env python3
import sys
def warshall_floyd(N, costs):
    for k in range(N):
        for i in range(N):
            for j in range(N):
                costs[i][j] = min(costs[i][j], costs[i][k] + costs[k][j])

def solve(N: int, M: int, u: "List[int]", v: "List[int]", l: "List[int]"):
    from itertools import combinations
    INF = 1 << 60
    costs = [[INF] * N for _ in range(N)]
    u = [uu-1 for uu in u]
    v = [vv-1 for vv in v]    
    for uu, vv, ll in zip(u, v, l):
        if 0 in (uu, vv):
            continue
        costs[uu][vv] = ll
        costs[vv][uu] = ll
    warshall_floyd(N, costs)
    nex = [(uu if vv == 0 else vv, ll) for uu, vv, ll in zip(u, v, l) if 0 in (uu, vv)]
    ans = min((costs[s][g]+l1+l2 for (s, l1), (g, l2) in combinations(nex, 2)), default=INF)
    return ans if ans <= INF else -1
        

# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    M = int(next(tokens))  # type: int
    u = [int()] * (M)  # type: "List[int]"
    v = [int()] * (M)  # type: "List[int]"
    l = [int()] * (M)  # type: "List[int]"
    for i in range(M):
        u[i] = int(next(tokens))
        v[i] = int(next(tokens))
        l[i] = int(next(tokens))
    print(solve(N, M, u, v, l))

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
