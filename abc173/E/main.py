#!/usr/bin/env python3
import sys
from functools import lru_cache

MOD = 1000000007  # type: int

def solve(N: int, K: int, A: "List[int]"):
    B = sorted(filter(lambda a: a>=0, A), key=abs, reverse=True)
    C = sorted(filter(lambda a: a<0, A), key=abs, reverse=True)
    i, j, k = 0, 0, 0
    ans = 1
    while k < K:
        if i >= len(B):
            ans = (ans * C[j] + MOD) % MOD
            j += 1
            k += 1
            continue
        if j >= len(C):
            ans = (ans * B[i] + MOD) % MOD
            i += 1
            k += 1
            continue
        # この時点でCBどちらも利用できる
        if k + 1 == K:
            ans = (ans * B[i] + MOD) % MOD
            i += 1
            k += 1
            continue
        # この時点でkには2以上の空きがある
        if j + 2 <= len(C):
            t = C[j] * C[j+1]
            if j + 2 <= len(B):
                tt = B[i] * B[i+1]
                if t > tt:
                    ans = ans * t % MOD
                    j += 2
                    k += 2
                    continue
                else:
                    ans = ans * tt % MOD
                    i += 2
                    k += 2
                    continue
            else:
                tt = B[i]
                if t > tt:
                    ans = ans * t % MOD
                    j += 2
                    k += 2
                    continue
        ans = ans * B[i] % MOD
        i += 1
        k += 1
        continue
    return ans

def solve2(N: int, K: int, A: "List[int]"):
    B = sorted(filter(lambda a: a>=0, A), key=abs)
    C = sorted(filter(lambda a: a<0, A), key=abs)
    i, j, k = 0, 0, 0
    ans = 1
    while k < K:
        if i >= len(B):
            ans = (ans * C[j] + MOD) % MOD
            j += 1
            k += 1
            continue
        if j >= len(C):
            ans = (ans * B[i] + MOD) % MOD
            i += 1
            k += 1
            continue
        # この時点でCBどちらも利用できる
        if k + 1 == K:
            ans = (ans * B[i] + MOD) % MOD
            i += 1
            k += 1
            continue
        # この時点でkには2以上の空きがある
        if j + 2 <= len(C):
            t = C[j] * C[j+1]
            if j + 2 <= len(B):
                tt = B[i] * B[i+1]
                if t < tt:
                    ans = ans * t % MOD
                    j += 2
                    k += 2
                    continue
                else:
                    ans = ans * tt % MOD
                    i += 2
                    k += 2
                    continue
            else:
                tt = B[i]
                if t < tt:
                    ans = ans * t % MOD
                    j += 2
                    k += 2
                    continue
        ans = ans * B[i] % MOD
        i += 1
        k += 1
        continue
    return ans

# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools
def main():
    def iterate_tokens():
        for line in sys.stdin:
            for word in line.split():
                yield word
    tokens = iterate_tokens()
    N = int(next(tokens))  # type: int
    K = int(next(tokens))  # type: int
    A = [int(next(tokens)) for _ in range(N)]  # type: "List[int]"
    print(solve(N, K, A))

def test():
    import doctest
    doctest.testmod()

if __name__ == '__main__':
    #test()
    main()
